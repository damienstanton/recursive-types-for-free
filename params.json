{"name":"Recursive Types For Free!","tagline":"Just wanting to read this classic paper by Wadler in something prettier than plain ASCII","body":"## Recursive types for free!\r\n### Philip Wadler\r\n### University of Glasgow\r\n### July 1990 [some typos fixed Aug 2008, Oct 2014]\r\n_DRAFT_\r\n\r\nRecursive types pervade programming: _lists_, _trees_, and _streams_ being\r\nthree of the most common examples.  Recursive types come in two\r\nprinciple flavours, least fixpoint or greatest fixpoint.  For example,\r\nthe least fixpoint\r\n```hs\r\nLfix X. 1 + A*X\r\n```\r\nyields lists with elements of type `A`, the least fixpoint\r\n```hs\r\nLfix X. A + X*X\r\n```\r\nyields binary trees with leaves of type `A`, and the greatest fixpoint\r\n```hs\r\nGfix X. A*X\r\n```\r\nyields streams with elements of type `A`.\r\n\r\nAdding recursive types can alter the nature of a type system.  The\r\npolymorphic lambda calculus has the pleasant propery of being strongly\r\nnormalising: all reduction sequences terminate in a normal form.  But\r\naugmenting this calculus with the type\r\n```hs\r\nLfix X. 1 + (X -> X)\r\n```\r\nhas the unpleasant consequence of introducing terms with no normal\r\nform.  Fortunately, strong normalisation can be preserved by a mild\r\nrestriction: don't allow the recursive type variable to appear in a\r\nnegative position.  The example violates this constraint, because the\r\nrecursive type variable `X` appears to the left of the function arrow.\r\n\r\nThus, it is safe to extend the polymorphic lambda calculus by adding\r\nleast fixpoint types with type variables in positive position.  Indeed,\r\nno extension is required: such types already exist in the language!  If\r\n`F X` represents a type containing `X` in positive position only, then least\r\nfixpoints may be defined in terms of universal quantification:\r\n```hs\r\nLfix X. F X  =  All X. (F X -> X) -> X.\r\n```\r\nThis introduces a new type, `T = Lfix X`. `F X`, satisfying the isomorphism\r\n`T ~ F T`.  Note that it is an isomorphism, not an equality:  the type\r\ncomes equipped with functions `in : T -> F T` and `out : F T -> T`.  This\r\nformula can be found, for instance, in [Freyd 89] and [Wraith 89].  It\r\nis not as widely known as it should be -- I know of several computer\r\nscientists who have re-invented this particular wheel.  The excellent\r\ntextbook by Girard, Lafont, and Taylor [GLT 89] gives several special\r\ncases, but not this general form.\r\n\r\nMore interestingly, polymorphic lambda calculus also contains greatest\r\nfixpoints.  These may be defined in terms of existential quantification\r\n```hs\r\nGfix X. F X  =  Exists X. (X -> F X) * X,\r\n```\r\nagain subject to the restriction that `X` appears only positively in `F X`.\r\nThis is a little surprising: greatest fixpoints allow infinite objects,\r\nsuch as streams, yet the strong normalisation property is preserved.\r\nSurprising, but not new: it was known previously that greatest\r\nfixpoints and strong normalisation could co-exist: both [Hagino 87] and\r\n[Mendler 87] describe type systems that include Lfix and Gfix and have\r\nstrong normalisation.  But the encoding provides a simple proof of this\r\nfact.  Hagino refers to the coding of least fixpoints, but says that he\r\ndoesn't know of a coding for greatest fixpoints; Mendler doesn't refer\r\nto either coding, but gives a lengthy proof that adding least and\r\ngreatest fixpoints to polymorphic lambda calculus preserves strong\r\nnormalisation.\r\n\r\n(As it turns out, not new either: I have since discovered that Wraith\r\nalso describes this encoding [Wraith 89], although there is a small\r\ntechnical error: he writes\r\n```hs\r\nGfix X. F X  =  Exists X. X -> (X -> F X),\r\n```\r\nwhich is incorrect.)\r\n\r\n\r\n\r\n### LEAST FIXPOINTS AS WEAK INITIAL ALGEBRAS\r\n\r\nLet's now look at the fixpoint result in a little more detail.\r\nThis will require a mild dose of category theory.  Don't panic:\r\nall terms will be explained as we go along.\r\n\r\nBy a functor F in polymorphic lambda calculus, we will mean an operation\r\ntaking types into types, and terms into terms, such that if `t : U -> V`\r\nthen `F t : F U -> F V`, and preserving identities and composition:\r\n`F id = id` and `F (f . g) = F f . F g`.  Every type `U` containing a type\r\nvariable `X` in positive positions only corresponds to a functor `F X = U`,\r\nwhich takes the type `T` into the the type `F T = U[T/X]`.\r\n\r\nAn object in a category is weakly initial if there is a map from it to\r\nevery other object, and initial if this map is unique.  In categorical\r\nterms, the least fixpoint of `F` corresponds to an initial _F-algebra_.  An\r\nF-algebra is a pair `(X,k)` consisting of an object `X` and an arrow\r\n`k : F X -> X`.  These form a category, where a morphism between `(X,k)` and\r\n`(X',k')` is given by an arrow `h : X -> X'` such that the diagram\r\n```\r\n                     k            \r\n             F X ----------> X   \r\n              |              |    \r\n              |              |    \r\n(1)\t          F h |              | h\r\n              |              |\r\n              |              |\r\n             F X' ---------> X'\r\n                     k'\r\n```\r\ncommutes.\r\n\r\nAssume `Lfix` is given by the equation:\r\n```hs\r\nT  =  Lfix X. F X  =  All X. (F X -> X) -> X.\r\n```\r\nAs a convenient abbreviation, we will write `T` for `Lfix X. F X`.\r\nThen we can define two functions:\r\n```hs\r\nfold  :  All X. (F X -> X) -> T -> X\r\nfold  =  \\X. \\k: F X -> X. \\t:T. t X k\r\n\r\nin    :  F T -> T\r\nin    =  \\s: F T. \\X. \\k: F X -> X. k (F (fold X k) s).\r\n```\r\nIt follows immediately that the diagram\r\n```\r\n                     in            \r\n             F T ----------> T   \r\n              |              |    \r\n              |              |    \r\n(2)\t F (fold X k) |              | fold X k\r\n              |              |\r\n              |              |\r\n             F X ----------> X\r\n                      k\r\n```\r\ncommutes.  In other words, `(T,in)` is an F-algebra from which\r\nthere is a map, called `(fold X k)`, to every other F-algebra;\r\nthat is, `(T,in)` is a weakly initial F-algebra.\r\n\r\nLet's consider what this means in a particular case.  Take\r\n```hs\r\nF X  =  1+X.\r\n```\r\nThe values of type `1+X` have the forms `(inl ())` and `(inr x)`, where `x:X`.\r\nIf `f : X -> Y`, then `F f : 1+X -> 1+Y`  is given by\r\n```hs\r\nF f (inl ())  =  inl ()\r\nF f (inr x)   =  inr (f x).\r\n```\r\nNow, define _Nat_ to be the least fixpoint of F:\r\n```hs\r\nNat  =  Lfix X. 1+X.\r\n```\r\nThis corresponds to the natural numbers: `(in (inl ()))` represents zero,\r\nand `(in (inr n))` represents the successor of `n`.  Let `k : 1+X -> X`.\r\nThen diagram (2) states that\r\n```hs\r\nfold X k (inl ())  =  k (inl ())\r\nfold X k (inr n)   =  k (inr (fold X k n)).\r\n```\r\nIf we take z = k (inl ()), and s x = k (inr x)), then we\r\ncan rewrite this in the familiar form:\r\n```hs\r\nfold X k 0      =  z\r\nfold X k (n+1)  =  s (fold X k n).\r\n```\r\nThat is, the value of `(fold X k)` is given for zero (namely, _z_), and is\r\nfound for `(n+1)` by recursively applying `(fold X k)` to `n`, and then\r\napplying a given function (namely, _s_) to this result.\r\n\r\nAs a second example, take\r\n```hs\r\nF X  =  1 + A*X.\r\n```\r\nThe values of type `1+A*X` have the forms `(inl ())` and `(inr (a,x))`,\r\nwhere `a:A` and `x:X`.  If `f : X -> Y`, then `F f : 1+A*X -> 1+A*Y` is\r\ngiven by\r\n```hs\r\nF f (inl ())     =  inl ()\r\nF f (inr (a,x))  =  inr (a, f x).\r\n```\r\nNow, define `(List A)` to be the least fixpoint of _F_:\r\n```hs\r\nList A  =  Lfix X. 1+A*X.\r\n```\r\nThis corresponds to lists with elements of type `A: (in (inl ())`\r\nrepresents the empty list, also written _nil_, and `(in (inr (a,as))`\r\nrepresents the list constructed with head a and tail as, also written\r\n`(cons a as)`.  Let `k : 1+A*X -> X`.  Then diagram (2) states that\r\n```hs\r\nfold X k (inl ())      =  k (inl ())\r\nfold X k (inr (a,as))  =  k (inr (a, fold X k as)).\r\n```\r\nIf we take `n = k (inl ())` and `c a x = k (inr (a,x))`, then\r\nwe can rewrite this in the familiar form\r\n```hs\r\nfold X k nil          =  n\r\nfold X k (cons a as)  =  c a (fold (X k as)).\r\n```\r\nThat is, the value of `(fold X k)` is given for nil (namely, _n_), and is\r\nfound for `(cons a as)` by recursively applying `(fold X k)` to as, and\r\nthen using a given function (namely, _c_) to combine  `a`  with the\r\nresult.\r\n\r\n\r\n### LEAST FIXPOINTS AS INITIAL ALGEBRAS\r\n\r\nSo far, we have considered only weak initial algebras.  We now give\r\nnecessary and sufficient conditions for this to be a true initial\r\nalgebra.  We first consider the problem for an arbitrary definitions of\r\n_T_, _fold_, _in_, and then specialise to the particular definitions we have\r\ngiven.\r\n\r\nIn order for `(T,in)` to be initial, the map `(fold X k)` must be\r\nunique, i.e., the only map that makes diagram (2) commute.\r\nLet h be an arbitrary map from `(X,k)` to `(X',k')`; then\r\ncombining (1) and (2) we have\r\n```\r\n                     in            \r\n             F T ----------> T   \r\n              |              |    \r\n              |              |    \r\n F (fold X k) |              | fold X k\r\n              |              |\r\n              |      k       |\r\n             F X ----------> X\r\n              |              |    \r\n              |              |    \r\n          F h |              | h\r\n              |              |\r\n              |              |\r\n             F X' ---------> X' ,\r\n                     k'\r\n```\r\nyielding a map `(h . fold X k)` from `(T,in) to (X',k')`.  But `(fold X' k')`\r\nshould be the only such map!  Thus, initiality entails that\r\n```\r\n            k                                fold X k\r\n    F X ----------> X                    T -----------> X\r\n     |              |                    |              |\r\n     |              |                    |              |\r\n(3)\t F h |              | h    implies    id |              | h\r\n     |              |                    |              |\r\n     |              |                    |              |\r\n    F X' ---------> X'                   T -----------> X' .\r\n            k'                              fold X' k'\r\n```\r\nFurther, since `(fold T in)` is a map `T -> T`, and id is also such\r\na map, initiality also implies that\r\n```hs\r\n(4)\t\t\tfold T in  =  id.\r\n```\r\nConversely, (3) and (4) imply than `(T,in)` is initial.\r\nChoosing an appropriate instance of (3) gives\r\n```\r\n            in                              fold T in\r\n    F T ----------> T                    T -----------> T\r\n     |              |                    |              |\r\n     |              |                    |              |\r\n F h |              | h    implies    id |              | h\r\n     |              |                    |              |\r\n     |              |                    |              |\r\n    F X ----------> X                    T -----------> X .\r\n            k                                fold X k\r\n```\r\nThe left-hand square states that `h` is a map from `(T,in)` into `(X,k)`;\r\nand the right-hand square, combined with (4), states that h must\r\nbe `(fold X k)`.  That is, `(fold X k)` is the only map from `(T,in)`\r\ninto `(X,k)`, as required.\r\n\r\nIf `(T,in)` is an initial _F-algebra_, then \"in\" is an isomorphism.\r\nBy functoriality, from `in : F T -> T` we have `(F in) : F (F T) -> F T`,\r\nhence `(F T, F in)` is an F-algebra.  The unique map from `(F,in)` into this\r\nalgebra is given by\r\n```hs\r\nout  :  T -> F T\r\nout  =  fold (F T) (F in).\r\n```\r\nTo see that \"in\" and \"out\" are inverses, stare at the following diagram:\r\n```\r\n                     in            \r\n             F T ----------> T   \r\n              |              |    \r\n              |              |    \r\n        F out |              | out\r\n              |              |\r\n              |     F in     |\r\n           F (F T) --------> F T\r\n              |              |    \r\n              |              |    \r\n         F in |              | in\r\n              |              |\r\n              |              |\r\n             F T ----------> T .\r\n                     in\r\n```\r\nThe top square is an instance of (2), and the bottom square commutes\r\ntrivially.  Hence `(in . out)` is a map from `(T,in)` to `(T,in)`; but id\r\nis also such a map, so by uniqueness we have `id = in . out`.\r\nNow from the upper square we have\r\n```hs\r\nout . in  =  F in . F out  =  F (in . out)  =  F id = id,\r\n```\r\ncompleting the proof.  It is precisely because \"in\" is an isomorphism\r\nthat we are justified in calling `T` a fixpoint of `F`, since we have\r\n`F T ~ T`; it is because `T` is initial that we are justified in calling\r\nit a least fixpoint.\r\n\r\nThe argument in the preceding two paragraphs works in any category.  In our\r\ngiven category, polymorphic lambda calculus, with the given definitions\r\nof \"fold\" and \"in\", we can go further.  Take (2) as the left-hand\r\nsquare of (3); then the right-hand square becomes,\r\n```\r\n                 fold T in            \r\n              T -----------> T  \r\n              |              |    \r\n              |              |    \r\n           id |              | fold X k\r\n              |              |\r\n              |              |\r\n              T -----------> X ,\r\n                 fold X k\r\n```\r\nor, in symbols,\r\n```hs\r\nfold X k (fold T in t)  =  fold X k t.\r\n```\r\nReducing both applications of (fold X k) yields\r\n```hs\r\n     (fold T in t) X k  =  t X k\r\n```\r\n(this is where we use the definition of \"fold\").  By the eta rules,\r\nit follows that\r\n```hs\r\n           fold T in t  =  t\r\n```\r\n(this is where we use properties of polymorphic lambda calculus).\r\nThus, for the given definitions, (3) implies (4), and hence (T,in) is\r\nan initial F-algebra exactly when (3) holds.\r\n\r\nLaw (3) does not follow from the reduction laws of polymorphic lambda\r\ncalculus, and indeed there are models that do not satisfy it.  But this\r\nlaw is satisfied in many models, including all those having the\r\nproperty of PARAMETRICITY (see [Reynolds 83], [Freyd 89], [Wadler 89],\r\n[Freyd 90], [AMSW 90]).  In particular, in the jargon of [Wadler 89],\r\nthe \"Theorem for Free\" derived from the type of \"fold\" is just this\r\nlaw.\r\n\r\n(A technical point:  The \"Theorems for Free\" result really deals with\r\nrelations, not functions.  In the diagram (3) each arrow denotes a relation\r\nrather than a function, namely, the relation induced by the function.\r\nExcept the arrow labeled \"id\" actually corresponds to the relation\r\nid' defined by the relation\r\n```hs\r\nid' =  (All r. (F r -> r) -> r).\r\n```\r\nHere `r->s` relates `f:X->Y to f':X'->Y'` if whenever `r` relates `x` to `x'`\r\nthen `s` relates `(f x)` to `(f' x')`.  And if `G` is an operation on\r\nrelations and types such that if `r:X<->X'` then `(G r):(G X)<->(G X')`,\r\nthen `(All r. G r)` relates `g : (All X. G X)` to `g' : (All X'. G X')`\r\n(these are both the same type), if whenever r is a relation from `X` to\r\n`X'` then `(g X) (G r) (g' X)`.  _It is not the case in all models that `id'``\r\nis the identity relation!_  This is the purpose of the identity lemma\r\nin [Reynolds 83] -- in any model satisfying this lemma, id' will be\r\nthe identity.  A parametric model is just one that satisfies the\r\nidentity lemma.  Hence, although the \"Theorems for Free\" result\r\napplies in any model, it is only in a parametric model that (3)\r\nand (4) must hold.)\r\n\r\n\r\n### ITERATORS AND RECURSORS\r\n\r\nThe \"fold\" operation is what has sometimes been called an iterator.\r\nThe value of `(fold X k x)` is computed by applying `(fold X k)`\r\nrecursively to each substructure of `x` and applying `k` to the result.\r\nMore formally, we can refer to the substructure of `x` by taking\r\n`x = in y`, for some `y : F T`, and we can apply `(fold X k)` to each\r\nsubstructure of `x` by taking `(F (fold X k) y)`. Then the sentence above\r\ncan be expressed in symbols:\r\n```hs\r\nfold X k (in y)  =  k (F (fold X k)).\r\n```\r\nThis fundamental property is just equivalent to saying that\r\n\"fold\" is a map of F-algebras.\r\n\r\nThe recursor is a slight variant of the iterator.  It is defined by\r\n```hs\r\nrec : All X. (F (X*T) -> X) -> T -> (X*T)\r\nrec = \\X. \\g: F (X*T) -> X. fold (X*T) <g, in . F snd>.\r\n```\r\nThe value of `(rec X g)` at `x` is computed by applying `(rec X g)` recursively\r\nto each substructure and applying g to the result, and pairing this with the\r\nvalue of `x`.  Thus where k expects a value computed on the substructure,\r\ng expects a value computed on the substructure paired with the substructure\r\nitself.  This is expressed by the laws:\r\n```hs\r\nfst (rec X g (in y))  =  g (F (rec X g) y),\r\nsnd (rec X g x)       =  x.\r\n```\r\nThe first is an easy consequence of the definition of \"rec\".  To derive\r\nthe second, instantiate (3) to yield:\r\n```\r\n     <g, in . F snd>                fold (X*T) <g, in . F snd>\r\n\r\n  F (X*T) -------> X*T                   T ----------> X*T\r\n     |              |                    |              |\r\n     |              |                    |              |\r\n     F snd |              | snd   implies   id |              | snd\r\n     |              |                    |              |\r\n     |              |                    |              |\r\n    F T ----------> T                    T -----------> T\r\n            in                               fold T in\r\n```\r\nThen the left square commutes trivially, the top line of the right square\r\nis \"rec\", and the bottom line is \"id\" by (4), yielding the desired law.\r\n\r\n\r\n\r\n### GREATEST FIXPOINTS\r\n\r\nGreatest fixpoints are exactly dual.  We will need a little notation\r\nfor dealing with existential types: unfortunately, there isn't a\r\nstandard one.  The following typing and reduction rules should serve to\r\nintroduce the notation, which is based on viewing existential types as\r\ngeneralised products:\r\n```\r\nProducts:\r\n\r\nA |- u:U    A |- v:V\r\n-----------------------\r\nA |- (u,v) : U*V\r\n\r\nA |- t : U*V     A, x:U, y:V |- w:W\r\n-------------------------------------\r\nA |- (case t of {(x,y) -> w}) : W\r\n\r\n(case (u,v) of {(x,y) -> w})  --->  w[u/x, v/y]\r\n\r\nExistentials:\r\n\r\nA |- v:V[U/X]\r\n-----------------------\r\nA |- (U,v) : Exists X.V\r\n\r\nA |- t : Exists X.V     A, y:V |- w:W\r\n-------------------------------------  (X not in A, W)\r\nA |- (case t of {(X,y) -> w}) : W\r\n\r\n(case (U,v) of {(X,y) -> w})  --->  w[U/X, v/y]\r\n\r\nWe will combine these in a straightforward way, so that, for instance,\r\n\r\ncase t of {(X,(k,x)) -> w}\r\n\r\nwill be used as an abbreviation for\r\n\r\ncase t of {(X,y) -> case y of {(k,x) -> w}}.\r\n```\r\nMitchell and Plotkin [MP 88] write (X,u) as (pack X u) and\r\n(case t of {(X,y) -> w}) as (abstype X y is t in w).\r\n\r\nWe now take the dual of the previous development.  The greatest\r\nfixpoint of `F` corresponds to a terminal _F-coalgebra_.  An F-coalgebra is\r\na pair `(X,k)` consisting of an object `X` and an arrow `k : X -> F X`, and a\r\nmorphism between `(X,k)` and `(X',k')` is given by an arrow `h : X -> X'`\r\nsuch that the diagram\r\n```\r\n                   k            \r\n            X ----------> F X   \r\n            |              |    \r\n            |              |    \r\n          h |              | F h\r\n            |              |\r\n            |              |\r\n            X' ---------> F X'\r\n                   k'\r\n```\r\ncommutes.  Assume Gfix is given by the equation:\r\n```hs\r\nT  =  Gfix X. F X  =  Exists X. (X -> F X) * X.\r\n```\r\nThen we can define two functions:\r\n```\r\nunfold  :  All X. (X -> F X) -> X -> T\r\nunfold  =  \\X. \\k: X -> F X. \\x:T. (X,(k,x)),\r\n\r\nout     :  T -> F T\r\nout     =  \\t:T. case t of {(X,(k,x)) -> F (unfold X k) (k x)}.\r\n```\r\nIt follows immediately that the diagram\r\n```\r\n                   k\r\n            X ----------> F X\r\n            |              |    \r\n            |              |    \r\n unfold X k |              | F (unfold X k)\r\n            |              |\r\n            |              |\r\n            T ----------> F T   \r\n                  out            \r\n```\r\ncommutes.  In other words, `(T,out)` is an F-algebra into which\r\nthere is a map, called `(unfold X k)`, from every other F-algebra;\r\nthat is, `(T,out)` is a weakly terminal F-coalgebra.\r\n\r\nAs before, if `(T,out)` is truly a terminal F-coalgebra, then \"out\"\r\nis an isomorphism, with the inverse given by\r\n```\r\nin  :  F T -> T\r\nin  =  unfold (F T) (F out).\r\n```\r\nFurthermore, we will have that `(T,out)` is terminal **iff** the condition\r\n```\r\n          k                               unfold X k     \r\n   X ----------> F X                   X -----------> T\r\n   |              |                    |              |\r\n   |              |                    |              |\r\n h |              | F h   implies    h |              | id\r\n   |              |                    |              |\r\n   |              |                    |              |\r\n   X' ---------> F X'                  X' ----------> T\r\n          k'                             unfold X' k'\r\n```\r\nholds.\r\n\r\n(A technical point: this equivalence depends on the equivalence\r\nof the surjective pairing rule and the equivalent rule for pair types:\r\n```\r\ncase t of {(x,y) -> h (x,y)}  =  h t,\r\ncase t of {(X,y) -> h (X,y)}  =  h t.\r\n```\r\nIf our calculus contains pairs and existentials as primitives, then\r\nit is reasonable to insist on these rules.  But if, as is often the\r\ncase, we define pairs and existentials in terms of universals, then\r\nthese rules will not necessarily hold.  But they will necessarily\r\nhold in all models satisfying parametricity!  So in parametric\r\nmodels we are assured the existence of true greatest fixpoints.)\r\n\r\nExample:  Streams of integers are yielded by the greatest fixpoint of\r\n`T(X) = Int * X`.  The formula above instantiates to\r\n```\r\n   IntStream\r\n=  Gfix X. Int * X\r\n=  Exists X. (X -> Int * X) * X\r\n~  Exists X. (X -> Int) * (X -> X) * X.\r\n```\r\nEssentially, what is going on here is that from the abstract type\r\n`(X, (h, t, x))` one can only extract terms of the form `(h (t^i x))`,\r\nwhich corresponds to the `i`'th element of the stream.\r\n\r\nHagino suggests that streams be defined by the operations\r\nunfold, head, and tail [Hagino 87].  We can define these by:\r\n```\r\nunfold  :  All X.  ((X -> Int) * (X -> X) * X) -> IntStream\r\n        =  \\X. \\(h, t, x). (X, (h, t, x))\r\n\r\nhead    :  IntStream -> Int\r\n        =  \\s. case s of {(X, (h, t, x)) -> h x}\r\n\r\ntail    :  IntStream -> IntStream\r\n        =  \\s. case s of {(X, (h, t, x)) -> (X, (h, t, t x))}\r\n```\r\nThese are just the transposition of \"unfold\" and \"in\"\r\nacross the isomorphism `(X -> Int * X) ~ (X -> Int) * (X -> X)`.\r\n\r\n\r\n### PRAGMATICS\r\n\r\nRegarding pragmatics, it is well known that the embedding of least\r\nfixpoints is less efficient than one would like.  For instance, the\r\noperation to find the tail of a list takes time proportional to the\r\nlength of the list: one would hope that this takes constant time.\r\nGreatest fixpoints have a dual problem: finding the tail of a stream is\r\ncheap, but consing an element onto the front of a stream is more\r\nexpensive than one would like.  So one would still be tempted to add\r\nleast and greatest fixpoints to a language for pragmatic reasons, though\r\nit is good to know that in doing so one does not change the language in\r\nany fundamental way (in particular, strong normalisation is still\r\npreserved).\r\n\r\nIs there a way of coding lists in polymorphic lambda calculus that `(a)`\r\nuses space proportional to the length of the list, `(b)` performs cons in\r\nconstant time, and `(c)` performs tail in constant time?  Or is there a\r\nproof that this is impossible?  So far as I know, this is an open\r\nquestion.\r\n\r\n\r\nACKNOWLEDGEMENT\r\n\r\nI'm grateful to John Hughes for comments on an earlier version of this\r\ntext.  [Update:  And to Fruhwirth Clemens and Gabor Greif for spotting\r\ntypos.]\r\n\r\n\r\nBIBLIOGRAPHY\r\n\r\n\r\n[AMSW 90]  S. Abramsky, J. Mitchell, A. Scedrov, and P. Wadler,\r\nTheorems for free, categorically.  In preparation.\r\n\r\n[Freyd 89]  P. Freyd, Structural polymorphism.  Series of three e-mail\r\nmessages to \"types\" newsgroup, March 1989.\r\n\r\n[Freyd 90]  P. Freyd, Recursive types reduced to inductive types.  In\r\nJ. Mitchell, editor, 5'th Symposium on Logic in Computer Science,\r\nPhiladelphia, June 1990.  IEEE.\r\n\r\n[GLT 89]  J.-Y. Girard, Y. Lafont, and P. Taylor, Types and Proofs.\r\nCambridge University Press, 1989.\r\n\r\n[Hagino 87]  T. Hagino, A typed lambda calculus with categorical type\r\nconstructors.  In Pitt, et al., editors, Category Theory in Computer\r\nScience, Edinburgh, September 1987.  LNC 283, Springer Verlag.\r\n\r\n[Mendler 87]  N. P. Mendler, Recursive types and type constraints\r\nin second-order lambda calculus.  In 2'nd Symposium on Logic in\r\nComputer Science, Ithaca, New York, June 1987.  IEEE.\r\n\r\n[MP 88]  J. C. Mitchell and G. D. Plotkin, Abstract types have\r\nexistential types.  ACM Transactions of Programming Languages,\r\n10(3):470--502, 1988.  Preliminary version appeared in Proceedings\r\n12'th ACM Symposium on Principles of Programming Languages, 1985.\r\n\r\n[Reynolds 83]  J. C. Reynolds,  Types, abstraction, and parametric\r\npolymorphism.  In R. E. A. Mason, editor, Information Processing 83,\r\npp. 513--523.  North-Holland, Amsterdam.\r\n\r\n[Wadler 89]  P. Wadler, Theorems for free!  In 4'th International\r\nConference on Functional Programming Languages and Computer\r\nArchitecture, London, September 1989.  ACM.\r\n\r\n[Wraith 89]  G. C. Wraith, A note on categorical data types.  In Pitt,\r\net al., editors, Category Theory in Computer Science, Manchester,\r\nSeptember 1989.  LNCS 389, Springer Verlag.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}